###### 비개발자를 위한 MySQL
# 조건절 심화

조건절에서 조건을 만드는 방법에는 앞서 조건절 기초 장에서 봤던 `>`, `<`, `=` 외에도 다양하게 있습니다. 이번 장에서는 다양한 조건을 만드는 방법에 대해서 알아봅시다.

## `!=`
`!=`는 같지 않다를 의미합니다. `=`의 반대입니다.

```sql
SELECT * FROM users WHERE age != 23;
```

이런식으로 사용하면 `users` 테이블에서 `age` 컬럼이 23이 아닌 데이터만 가져올 수 있습니다.

## `BETWEEN`
만약 **범위**로 조건을 지정하고 싶다면 어떻게 해야할까요? 한 번 살펴봅시다.

|손님  |나이|소지금|
|------|----|------|
|이선협|23  |0     |
|김지환|23  |1234  |
|남세현|32  |9000  |
|윤명근|28  |53000 |
|배수항|35  |5000  |

위 테이블은 우리 가게의 `손님` 테이블입니다. 우리는 여기서 20대인 손님의 리스트를 가지고오고 싶습니다. 이럴 때는 다음과 같이 사용할 수 있습니다.

```sql
SELECT * FROM customers WHERE age >= 20 AND age < 30;
```

간단한 쿼리입니다. `age` 컬럼이 20 이상이고 30 미만일 경우를 `AND` 연산자를 사용하여 조건을 만들었습니다. 이 간단한 쿼리를 우리는 `BETWEEN`을 사용해 좀 더 간단하게 만들 수 있습니다. `BETWEEN`은 번역 그대로 **~사이에**라는 의미로 사용됩니다. `BETWEEN`을 사용하면 의미상으로 이해가 빨리되고 중복된 타이핑을 줄일 수 있다는 장점이 있습니다.

```sql
SELECT * FROM customers WHERE age BETWEEN 20, 29;
```

위 쿼리를 보면 `20, 29`로 되어 있습니다. `BETWEEN`은 '이상', '이하'로 작동하기 때문에 유의합시다.

## `IN`
데이터를 가져올 때 여러가지 데이터만 콕 찝어서 가지고 오고 싶을 때가 있습니다. 예시로 우리 가게의 `주문` 테이블을 살펴봅시다.

|손님  |주문메뉴|가격 |
|------|--------|-----|
|이선협|가지구이|10000|
|김지환|치킨덥밮|8000 |
|남세현|돈까스  |9000 |
|윤명근|한정식  |53000|
|이선협|떡튀순  |5000 |

위와 같은 데이터가 `주문` 테이블에 있다고 가정해봅시다. 이 데이터에서 손님 컬럼 중 '이선협'과 '윤명근'에 대해서만 가지고 오고 싶을 경우 다음과 같이 SQL을 작성할 수 있습니다.

```sql
# sales가 매출 테이블 이름이라고 가정했습니다.
SELECT * FROM sales WHERE customer_name = "이선협" OR customer_name = "윤명근";
```

이전 장에서 배운 것 처럼 `OR`를 이용하여 여러 조건을 사용했습니다. 하지만 여기서 '남세현', '김지환'에 대한 데이터도 가지고오고 싶다면 조건이 총 4개까지 늘어나게 됩니다. 조건이 많아지면 쿼리가 너무 길어지게 됩니다. 이럴때 `IN`이라는 예약어를 사용합니다.

```sql
SELECT * FROM sales WHERE customer_name IN ("이선협", "김지환", "남세현", "윤명근");
```

짜잔! 이런식으로 쿼리를 만들면 굳이 `OR`를 이용하여 길게 나열하지 않아도 됩니다. 사실, `IN`은 아직까지 그렇게 매력적으로 보이지는 않습니다. 하지만 나중에 **서브쿼리(Subquery)**를 배우고나면 `IN`은 정말 강력한 무기가 됩니다. 나중을 기대해주세요!

## `LIKE`
위 예제에서 우리는 문자열을 조건으로 쿼리를 만들었습니다. 단순한 숫자를 조건으로 쿼리를 만드는 것과 크게 다르지 않습니다. 하지만 우리는 좀 더 고차원적인 조건을 만들고 싶습니다! 예로, 우리는 우리 가게의 서비스에 대한 평가글에서 '최고'라는 단어가 들어간 데이터만 가져오고 싶을 수 있습니다. 우리는 이럴 때 `LIKE`라는 것을 사용할 수 있습니다.

```sql
SELECT * FROM orders WHERE aticle LIKE "%최고%";
```

위 예제 처럼 쿼리를 만든다면 손님이 남기고간 평가글에서 '최고'라는 단어가 들어간 데이터만 가져올 수 있습니다. 그럼 `LIKE`에 대해서 좀 더 알아봅시다. `%`가 보이시나요? 여기서 `%`는 **다수의 불특정 문자열**을 의미합니다. `%` 부분에는 어떠한 문자열이 들어오더라도 상관 없다는 뜻이죠. `%`는 이렇게도 사용할 수 있습니다.

```sql
SELECT * FROM orders WHERE aticle LIKE "%마무리";
```

이번에는 `%`가 맨 앞에만 있습니다. 이렇게 사용하면 `article` 컬럼에서 맨 마지막이 '마무리'인 데이터만 가져오게 됩니다.

```sql
SELECT * FROM orders WHERE aticle LIKE "처음%";
```

마찬가지로 맨 뒤에만 `%`를 넣을 수도 있습니다. 이렇게 사용하면 `article` 컬럼에서 맨 처음이 '처음'인 데이터만 가져오게 됩니다.

```sql
SELECT * FROM orders WHERE aticle LIKE "%맛이%최고%";
```

심지어 이렇게도 사용할 수 있습니다! 이러면 '맛이'라는 단어와 '최고'라는 단어가 들어간 데이터만 볼 수 있습니다. 이렇게 사용하면 좀 더 정확한 데이터를 얻을 수 있겠죠?

`LIKE`에는 `%` 말고도 `_` 라는 것을 사용할 수 있습니다. `%`가 **다수의 불특정 문자열**이었다면 `_`는 **하나의 불특정 문자**를 의미합니다.

```sql
SELECT * FROM users WHERE name LIKE "이_협";
```

위와 같이 쿼리를 사용한다면 '이선협', '이상협', '이준협' 등 가운데 글자는 어떠한 문자가 와도 상관없지만 양옆은 '이'와 '협' 으로 고정되어 있습니다. 다음으로 `IS`에 대해서 알아봅시다.

## `IS`
사실, `IS`는 사용할 일이 많지 않습니다. `NULL`에 대해서 들어보셨나요? 컴퓨터 프로그래밍에서 `NULL`이란 **아무것도 존재하지 않음**이라는 뜻입니다. 데이터에서는 NULL이 존재할 수 있습니다. 다음 테이블을 봅시다.

|메뉴    |가격 |원가 |조리시간(초)|
|--------|-----|-----|------------|
|가지구이|10000|8000 |400         |
|스테이크|21000|12000|640         |
|라면    |3000 |1500 |180         |
|김밥    |1000 |500  |NULL        |

Whoop! 김밥 로우의 `조리시간(초)` 부분이 NULL이군요. 우리 가게를 운영하는 주인이 아무런 데이터도 넣지 않았나봅니다. 우리는 데이터가 없는 항목을 체크하고 싶습니다. 다음과 같은 쿼리를 사용하면 되겠군요.

```sql
SELECT * FROM menus WHERE cooking_time IS NULL;
```

간단하죠? `그런데 cooking_time = NULL도 가능하지 않나요?` 아뇨, NULL은 `IS NULL`을 이용해야만 체크할 수 있습니다. 사실 `IS NULL`은 하나의 [연산자](http://dev.mysql.com/doc/refman/5.7/en/comparison-operators.html#operator_is-null) 입니다. 우리는 이렇게 `NULL`을 가진 데이터를 얻을 수 있습니다. 하지만 의도적으로 데이터에 `NULL`을 넣는 경우도 많습니다. 그런 경우는 해당 데이터에 대해서 **모를 때**와 **말 그대로 아무것도 없을 때** 입니다. 만약 이런 데이터를 제외하고 싶다면 `NOT`에 대해서 알아봅시다.

## `NOT`
`NOT`은 **~아니다**라는 뜻입니다. `NOT`은 앞서 배운 `LIKE`와 `IN`, `IS`, `BETWEEN`에 대해서 사용할 수 있습니다. `NOT`을 사용하면 조건을 사용하여 가져오는 데이터의 **역집합**으로 가져오게 됩니다.

```sql
SELECT * FROM orders WHERE aticle NOT LIKE "%맛이%최고%";
```

위 쿼리는 `article` 컬럼에서 '맛이', '최고' 두 단어가 없는 데이터를 가져오는 쿼리입니다. 만약 여기서 `NOT`을 뺀다면 위에서 봤던 쿼리와 동일한 결과를 가져오게 됩니다.

```sql
SELECT * FROM menus WHERE cooking_time IS NOT NULL;
```

마찬가지로 `IS`에 `NOT`을 붙이면 `NULL`이 아닌 데이터만 가져오게 됩니다.

```sql
SELECT * FROM sales WHERE customer_name NOT IN ("이선협", "김지환", "남세현", "윤명근");
```

`IN`에도 사용이 가능합니다. 결과는 "이선협", "김지환", "남세현", "윤명근"이라는 손님을 제외한 나머지 값입니다.

```sql
SELECT * FROM customers WHERE age NOT BETWEEN 20, 29;
```

`BETWEEN`에도 사용이 가능합니다. 이 경우 `age` 컬럼에서 20~29 사이를 제외한 나머지를 반환합니다.

## `REGEXP`
`REGEXP`는 **정규표현식**이라는 형식 언어를 통해 조건을 만드는 연산자 입니다. 이번 장에서는 정규표현식에 대해서 자세히 배우지는 않습니다. 만약 미리 배우고 싶다면 [위키피디아](https://ko.wikipedia.org/wiki/%EC%A0%95%EA%B7%9C_%ED%91%9C%ED%98%84%EC%8B%9D)에 자세한 내용을 볼 수 있습니다. 그리고 [Rubular](http://www.rubular.com/)에서 바로 연습할 수 있습니다. 이번 장에서는 간단한 예제만 보고 넘어가겠습니다.

```sql
SELECT * FROM users WHERE email REGEXP '^[0-9a-zA-Z]([-_\.]?[0-9a-zA-Z])*@[0-9a-zA-Z]([-_\.]?[0-9a-zA-Z])*\.[a-zA-Z]{2,3}$'
```

위 쿼리는 정규표현식을 이용하여 정상적인 이메일인지 판단하는 쿼리입니다.

## 마치며
이번 장에서는 `WHERE`에서 사용되는 다양한 연산자들에 대해서 배웠습니다. [다음 장](ORDER.md)에서는 가져온 데이터를 정렬하는 방법에 대해서 알아봅시다.

## 지적, 수정사항에 대해서
Github 계정이 있으신 분들은 Issue에 지적사항을 등록해주시거나 직접 수정하여 Pull request를 주시면 반영하도록 하겠습니다. <br>Github 계정이 없으신 분들은 kciter@naver.com를 통해 지적사항을 보내주세요. :smile:

## 라이센스
<a rel="license" href="http://creativecommons.org/publicdomain/mark/1.0/">
<img src="https://licensebuttons.net/p/mark/1.0/88x31.png" alt="Public Domain Mark" />
</a>

이 문서는 [CC0 라이센스](LICENSE)를 따릅니다.

특허권 또는 상표권은 CC0에 의해 영향을 받지 않으며, 퍼블리시티권 및 프라이버시권 등 저작물 자체에 대해 또는 저작물 이용에 대해 타인이 갖는 권리 또한 영향을 받지 않습니다.

달리 정하지 않은 한, 본 저작물의 인증자는 관련법에서 허용하는 최대 한도 내에서 저작물에 대해 아무런 보증도 하지 않으며 저작물의 모든 이용에 관한 어떠한 책임도 지지 않습니다.

저작물을 사용하거나 인용할 때 저자나 인증자로부터 승인을 받았다는 뜻을 시사하여서는 안됩니다.
